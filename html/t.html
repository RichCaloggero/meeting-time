<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Meeting Time</title>
<link rel="shortcut icon" href="#" type="image/x-icon">
<style>
nav ul {list-style-type: none;}
</style>
</head>
<body>

<nav><ul><li>
<button data-action="display-instructions" accesskey="h">Instructions</button>
</li><li>
<button data-action="new-meeting" accesskey="n">New meeting</button>
</li>
<!--<li><button data-action="update-meeting" aria-pressed="false" accesskey="u">Update meeting</button>
</li>
<li><button data-action="delete-meeting" accesskey="d">Delete meeting</button>
</li>
-->
</ul>

<main>
</main>

<output id="status"></output>

<script>
const origin = "";
const $nav = $("nav");
const $main = $("main");
const $status = $("#status");
const actions = {
back: back,
"display-instructions": displayInstructions,
"new-meeting": newMeeting,
"update-meeting": updateMeeting,
"delete-meeting": deleteMeeting,
"save-meeting-data": saveMeetingData,
"load-meeting-data": loadMeetingData,
"add-proposal": addProposal,
"delete-proposal": deleteProposal,
"find-meeting": findMeeting,
"vote": vote,
}; // actions

const meetings = new Map();

meetings.set("test0", {
id: "test0",
info: "some info",
proposals: [
{voteCount: 2, timestamp: toTimestamp("2024-07-10", "12:00:00")},
{voteCount: 1, timestamp: toTimestamp("2024-07-10", "11:00:00")}
]});

const instructions = `
<div class="instructions">
<h1 id="meetingtime">MeetingTime</h1>
<p>This webapp is meant to help coordinate events such as online meetings among several remote participants. It is designed to store only data about the event which is absolutely necessary for it's function. Users do not need to create accounts or provide eMail addresses to use the app!</p>
<h2 id="operation">Operation</h2>
<ul>
<li>Click "New meeting" to create an entry
<ul>
<li>the URL shown as the meeting ID must be copied and saved</li>
<li>the creator is responsible for providing this URL to all other participants</li>
<li>click "submit" to create the entry</li>
</ul></li>
<li>Updating
<ul>
<li>anyone with the URL can update the meeting with new timeslot proposals, as well as vote on existing proposals which increases their vote count by one</li>
<li>proposals sort with highest vote count first</li>
<li>Click "submit" to update the entry</li>
</ul></li>
<li>entries are automatically removed after they remain static for 7 days (i.e. not updated)</li>
</ul>
<h2 id="concurrent-updates">Concurrent updates</h2>
<p>If another user updates the meeting you are currently updating, a warning is generated and the entry is reloaded displaying the changes entered by the other user, possibly overwriting any changes you may have made. This shouldn't happen often, and the amount of data lost is minimal, essentially any timeslot proposals you may have voted on would be lost.</p>
</div>
`;

const meetingTemplate = `

<div><label>Meeting info:<br>
<textarea required class="meeting-info" name="meeting-info" rows="5" cols="80"></textarea>
</div>

<fieldset class="new-proposal"><legend><h3>New proposal</h3></legend>
<label>Date: <input id="date" name="date" type="date" id="proposal-date"></label>
<br><label>Time: <input id="time" name="time" type="time" id="proposal-time"></label>
<br><button data-action="add-proposal" type="button">Add proposal</button>
</fieldset>

<h3>Current proposals</h3>
<table class="proposals"><tr>
<th>vote</th>
<th>count</th>
<th>date</th>
<th>time</th>
</tr></table>

<div>
<label>Meeting ID: <input class="meeting-id" name="meeting-id" readonly></label>
<span hidden id="id-description">copy to clipboard and eMail to other participants</span>
</div>
`; // meetingTemplate

/// connect to server

let clientID = 0;
const server = new EventSource(`${origin}/events`);

server.addEventListener("open", e => {
//console.log("connecting...");
statusMessage("Connecting ...")
});

server.addEventListener("connected", e => {
const data = JSON.parse(e.data);
clientID = data.id;
loadAllMeetings(data.meetings, meetings);
document.addEventListener("click", performAction);
statusMessage("connected.");

if (isUpdateRequest()) updateMeeting();
else performAction("display-instructions");
}); // connected

server.addEventListener("update", e => {
data = JSON.parse(e.data);
//console.log("update: ", data);
meetings.set(data.meeting.id, data.meeting);
if (isUpdateMode() && $("form")["meeting-id"].value === data.meeting.id) merge(data.meeting);
}); // update

server.onerror = e => statusMessage(`error from server:\n${e}`);


function loadAllMeetings (list, map) {
for (const meeting of list) {
map.set(meeting.id, meeting);
} // for
} // loadAllMeetings


function performAction (e) {
const $action = typeof(e) === "string"?
$(`[data-action='${e}']`)
: (e.submitter || e.target);

const actionId = $action.dataset.action;
const $form = $action.closest("form");

if ($action.hasAttribute("aria-current")) return;

const action = actions[actionId];
//console.log("action: ", actionId, action);
if (not(action)) return; // fail silently

action({$action, $form, update: getUpdateRequest()});

resetNavigation();
statusMessage($action.dataset.responseMessage);
} // performAction


/// actions

function displayInstructions () {
if ($("form")) {
$("h1").hidden = true;
$("form").hidden = true;
} // if

$("main").insertAdjacentHTML("afterBegin", instructions);
if ($("form")) $(".instructions").insertAdjacentHTML("beforeEnd", `<button data-action="back" accesskey="x">Back</button>`);
} // instructions


function back () {
$(".instructions").remove();
$$("main [hidden]").forEach(x => x.hidden = false);
$("form .meeting-info").focus();
} // back


function newMeeting () {
clearForm();
meetingId = generateMeetingId();
//console.log("new id: ", meetingId);

$("main").insertAdjacentHTML("afterBegin",
`<h1>New Meeting</h1>
<form class="new-meeting">
${meetingTemplate}
<button data-action="save-meeting-data" data-response="Meeting created" type="button">Submit</button>
`);

$(".meeting-id").setAttribute("aria-describedby", "id-description");
$("#id-description").hidden = false;
$(".meeting-id").dataset.value = meetingId;
$(".meeting-id").value = generateURL(meetingId);
$(".meeting-id").select();
$(".meeting-info").focus();
} // newMeeting


function updateMeeting () {
clearForm();

$("main").insertAdjacentHTML("afterBegin", 
`<h1>Update meeting</h1>
<form id="update-meeting">
${meetingTemplate}

<button data-action="save-meeting-data" data-response="Meeting updated" type="button">Submit</button>
</form>
`);

if (isUpdateRequest()) {
$(".meeting-id").dataset.value = getUpdateRequest();
$(".meeting-id").hidden = true;
if (not(findMeeting())) {
statusMessage("meeting not found.");
return;
} // if

} else {
$("form [name=meeting-id").removeAttribute("readonly");
$("form [name=meeting-id").insertAdjacentHTML("afterEnd",
`<button data-action="find-meeting" type="button">Find meeting</button>
`);
} // if


$("form")["meeting-info"].focus();
} // updateMeeting

function deleteMeeting () {
} // deleteMeeting

function addProposal () {
const $proposal = $("form .new-proposal");
const date = $(".new-proposal #date").value;
const time = $(".new-proposal #time").value;
if (not(date) || not(time)) {
statusMessage("invalid timeslot");
return;
} // if

const timestamp = toTimestamp(date, time);
if (not(Number.isInteger(timestamp))) {
statusMessage("invalid date or time");
return;
} // if

const $p =  findProposal($$("form .proposal"), date, time);
if ($p) {
statusMessage("timeslot already proposed.");
return;
} // if

const proposal = {
timestamp, voteCount: 1,
};

const proposalCount = $$get("proposal").length;

$("form .proposals").insertAdjacentHTML("beforeEnd", createProposal(proposal, proposalCount+1));
saveMeetingData();
} // addProposal

function createProposal (proposal, count) {
const {timestamp, voteCount} = proposal;
const d = new Date(timestamp);
const date = d.toLocaleDateString();
const time = d.toLocaleTimeString();

const dateLabel = `date-${count}`;
const timeLabel = `time-${count}`;

return `<tr class="proposal">
<!--<td><input type="checkbox" data-action="vote" aria-labelledby="${dateLabel} ${timeLabel}"></td>
-->
<td><input type="checkbox" data-action="vote"
aria-label="${createLabel(voteCount, date, time)}">
</td>

<td><output class="vote-count">${proposal.voteCount}</output></td>
<td class="date" id="${dateLabel}">${date}</td>
<td class="time" id="${timeLabel}">${time}</td>
</tr>`; // proposal
} // createProposal

function createLabel (voteCount, date, time) {
return `currently ${voteCount} votes for ${time}, on ${date}`;
} // createLabel

function deleteProposal ($button, $form) {
$proposal = $button.closest(".proposal");
if (not($proposal)) return;
$proposal.remove();
proposalCount -= 1;
} // deleteProposal

function saveMeetingData (actionData) {
const $proposals = $("form .proposals");

const meeting = {};

meeting.id = $(".meeting-id").dataset.value;
meeting.info = valueOf("meeting-info")[0];
meeting.proposals = $$(".proposal")
.map($p => {
return {
voteCount: voteCount($p),
timestamp: toTimestamp(date($p), time($p))
};
}); // map

meetings.set(meeting.id, meeting);

sendMeetingData(meeting);
} // saveMeeting

function findMeeting () {
const meetingId = $(".meeting-id").dataset.value;

if (not(meetings.has(meetingId))) {
return false;
} // if

loadMeetingData(meetings.get(meetingId));
$("form")["meeting-info"].focus();
return true;
} // findMeeting

function vote (data) {
$action = data.$action; // the specific checkbox

const $proposal = $action.closest(".proposal");
$count = $(".vote-count", $proposal);
$count.value = $action.checked?
Number($count.value) + 1
: Number($count.value) - 1;
$action.setAttribute("aria-label", createLabel($count.value, date($proposal), time($proposal)));
} // vote

/// utilities

function loadMeetingData (data) {
$$get("meeting-info")[0].value = data.info;

$proposals = $$get("proposals")[0];

let proposalCount = 0;
for (proposal of data.proposals.sort(orderByVoteCount)) {
proposalCount += 1;
$proposals.insertAdjacentHTML("beforeEnd", createProposal(proposal, proposalCount));
} // for

function orderByVoteCount (p1, p2) {
const n1 = p1.voteCount, n2 = p2.voteCount;
return n1 < n2? 1 // largest first
: n1 > n2? -1
: 0;
} // orderByVoteCount
} // loadMeetingData

function resetNavigation () {
$$("nav [aria-current]").forEach(x => x.removeAttribute("aria-current"));

if ($(".instructions") && not($(".instructions").hidden)) $("nav [data-action='display-instructions']").setAttribute("aria-current", "page");
else if ($("form.new-meeting") && not($("form.new-meeting").hidden)) $("nav [data-action='new-meeting']").setAttribute("aria-current", "page");
} // resetNavigation


function clearForm () {
$("main").innerHTML = "";
} // clearForm


function generateMeetingId () {
let id;
do {
id = btoa(Math.random());
} while (meetings.has(id));

return id;
} // generateMeetingId

function isUpdateRequest () {
const url = new URL(location);
return url.searchParams.has("update");
} // isUpdateRequest

function getUpdateRequest () {
return isUpdateRequest()?
new URL(location).searchParams.get("update") : "";
} // getUpdateRequest

function isUpdateMode () {
return $("form#update-meeting");
} // isUpdateMode

function merge (data) {
statusMessage("someone else updated this meeting - reloading (changes may be lost)");
$$get("proposals")[0].innerHTML = "";
loadMeetingData(data);
} // merge

function integrateMeetingData (data) {
$("form")["meeting-info"].value = data.info;

for (proposal of data.proposals) {
const $proposal =  findProposal($$("form .proposal"), data.date, data.time);
if ($proposal && $("input", $proposal).checked) proposal.voteCount += 1;
} // for
$("form .proposals").innerHTML = "";

loadMeetingData(data);
} // integrateMeetingData

function findProposal (list, date, time) {
if (not(list) || not(list instanceof Array) || list.length === 0) return false;
if (list[0].matches("tr")) return list.find(
$tr => $(".date", $tr).textContent === date
&& $(".time", $tr).textContent === time
);
else return list.find(
p => p.date === date && p.time === time
);
} // findProposal

function statusMessage (text) {
if (text) setTimeout(() => $("#status").textContent = text, 200);
} // statusMessage

function generateURL (id) {
const url = location.toString();
return `${url.split("?")[0]}?update=${id}`;
} // generateURL

/// accessors

function meetingInfo(value, returnUi) {
const ui = ui(".meeting-info");
if (returnUi) return ui;
if (value) return set(value, ui);
return valueOf(ui);
} // meetingInfo

function set (value, ui) {
if (ui.hasAttribute("value")) ui.value = value
else if (ui.hasAttribute("data-value")) ui.dataset.value = value
return ui;
} // set

function valueOf (ui) {
if (ui.hasAttribute("value")) return ui.value;
else if (ui.hasAttribute("data-value")) return ui.dataset.value;
else return null;
} // valueOf

function $ui (arg) {
return isString(arg)?
$(`${arg}, .${arg}, [name="${arg}"], #${arg}`)
  : arg;
} // ui

function $$get(selector) {
const elements = $$(`form ${selector}`);
return elements && elements.length > 0?
elements : $$(`form .${selector}`);
} // $$get

function valueOf (selector) {
return $$get(selector)
.map(x => x.value || x.textContent);
} // valueOf
function date ($proposal) {
return $proposal.matches("#new-proposal")?
$("#date", $proposal).value : $(".date", $proposal).textContent;
} // date

function time ($proposal) {
return $proposal.matches("#new-proposal")?
$("#time", $proposal).value : $(".time", $proposal).textContent;
} // date

function voteCount ($proposal) {return Number($(".vote-count", $proposal).textContent);}

function toTimestamp (date, time) {
return Date.parse(`${date} ${time}`);
} // toTimestamp

function toDate(timestamp) {return new Date(timestamp).toLocaleDateString();} // toDate
function toTime(timestamp) {return new Date(timestamp).toLocaleTimeString();} // toDate

function $ (s, c = document) {return c.querySelector(s);}
function $$ (s, c = document) {return [...c.querySelectorAll(s)];}

function not (x) {return !x;}

/// server stuff

async function sendMeetingData (meeting) {
//console.log("sendMeetingData(): ", clientID, meeting);
if (clientID === 0) {
statusMessage("Connection to server not established.");
return;
} // if

try {
const res = await fetch(`${origin}/data`, {
method: "POST", 
//mode: "cors",
headers: {
'Accept': 'application/json',
'Content-Type': 'application/json',
"Cache-Control": "no-cache"
},
//"origin-when-cross-origin": true,
body: JSON.stringify({clientID: clientID, meeting})
}); // fetch


//console.log("fetch succeeded");

const responseData = await res.json();
//console.log("response data: ", responseData);
if (not(responseData)) statusMessage("invalid response from server!");
else if (not(responseData.status)) statusMessage(`error: ${responseData.error}`);

} catch (e) {
statusMessage(`fetch failed.\n${e.message}`);
} // try
} // sendMeetingData



</script>
</body>
</html>
