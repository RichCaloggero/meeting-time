import fs from "fs";import path from "path";import express from "express";import cors from "cors";import http from "http";//import https from "https";const app = express();const port = 3000;const clientMap = new Map();let nextClientID = 0;const meetings = new Map();loadMeetingData("meetings.json", meetings);const httpServer = http.createServer(app);const corsOptions = {origin: "https://richcaloggero.space:443",methods: "POST",allowedHeaders: "Content-Type",optionsSuccessStatus: 200};app.use(express.json()) // for parsing application/jsonapp.use(cors(corsOptions));app.get("/client", (req, res) => {console.log("request client: ", req.params.name);res.sendFile("meetingTime.html", {root: path.join(process.cwd(), "html")});});//app.post("/data", async (req, res) => {app.post("/data", cors(corsOptions), async (req, res) => {//res.setHeader("Access-Control-Allow-Origin", "*");const query = req.query;const data = req.body;console.log("got data: ", data);updateMeetingList(data.meeting);respondToClients(data.clientID, data.meeting);try {fs.writeFileSync("meetings.json", JSON.stringify([...meetings.values()]), {flush: true});res.json({status: true, error: ""});} catch(error) {res.json({status: false, error: error});} // tryreturn;}); // postapp.get("/events", async (req, res) => {const clientID = clientInit (res);sendClientEvent(res, "connected", {id: clientID, meetings: [...meetings.values()]});console.log(`client ${clientID} connected.`);const intervalID = setInterval(() => {sendClientEvent(res, "keepAlive");}, 30000); // send keepAlive every 30 secondsres.on('close', () => {console.log('client dropped me');clearInterval(intervalID);clientMap.delete(clientID);console.log("client map: ", clientMap);res.end();}); // interval}); // server sent eventshttpServer.listen(port, () => {console.log(`http server Listening on port ${port}`);});function updateMeetingList (meeting) {//console.log("updateMeetingList: ", meeting);meetings.set(meeting.id, meeting);} // updateMeetingListfunction respondToClients (clientID, data) {// respond to all othersclientMap.forEach((clientData, id) => {if (id !== clientID) {sendClientEvent(clientMap.get(id).res, "update", {id, from: clientID, meeting: data});} // if}); // forEach} // respondToClientsfunction clientInit (res) {const id = (nextClientID += 1);res.setHeader("Cache-Control", "no-cache");res.setHeader("X-Accel-Buffering", "no");res.setHeader("Content-Type", "text/event-stream");//res.setHeader("Connection", "keep-alive");res.flushHeaders(); // flush the headers to establish SSE with clientclientMap.set (id, {id, res});return id;} // clientInitfunction sendClientEvent (res, event, data) {if (event === "keepAlive") {res.write(":keep alive\n");} else {res.write(`event: ${event}data: ${isString(data)? data : JSON.stringify(data)}\n`);} // if} // sendClientEventfunction loadMeetingData (file, map) {try {const list = JSON.parse(fs.readFileSync(file));if (not(list) || not(list instanceof Array)) throw new Error("database invalid");for (const meeting of list) {map.set(meeting.id, meeting);} // for} catch (e) {console.log("database invalid; setting to empty list");fs.writeFileSync("meetings.json", "[]");} // tryconsole.log(`${map.size} items loaded.`);} // loadMeetingDatafunction isString (x) {return typeof(x) === "string" || (x instanceof String);} function not(x) {return !x;}